/*
 *
 *  Copyright 2004 Cordys R&D B.V. 
 *
 *  This file is part of the Cordys JMS Connector. 
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.cordys.coe.ac.jmsconnector.messages;

import java.text.MessageFormat;
import java.util.Locale;

import com.eibus.localization.message.Message;
import com.eibus.localization.message.MessageSet;

/**
 * This code is generated by running com.cordys.coe.cep.wizards.localization.CoEMessageGenerator.
 */
public class LogMessages
{
	/**
	 * Holds the definition of the message set.
	 */
	public static final MessageSet MESSAGE_SET = MessageSet.getMessageSet("Cordys.CoE.JMSConnector.LogMessages");

	/**
	 * Holds the definition of the message with ID connectorManagementDescription.
	 * Message text:
	 * This component can access messaging middleware via JMS
	 */
	public static final Message CONNECTOR_MANAGEMENT_DESCRIPTION = MESSAGE_SET.getMessage("connectorManagementDescription");
	/**
	 * Holds the definition of the message with ID coelibVersionMismatch.
	 * Message text:
	 * Coelib version mismatch.
	 */
	public static final Message COELIB_VERSION_MISMATCH = MESSAGE_SET.getMessage("coelibVersionMismatch");
	/**
	 * Holds the definition of the message with ID connectorStarting.
	 * Message text:
	 * Starting JMS Connector
	 */
	public static final Message CONNECTOR_STARTING = MESSAGE_SET.getMessage("connectorStarting");
	/**
	 * Holds the definition of the message with ID connectorStarted.
	 * Message text:
	 * JMS connector started.
	 */
	public static final Message CONNECTOR_STARTED = MESSAGE_SET.getMessage("connectorStarted");
	/**
	 * Holds the definition of the message with ID connectorStartException.
	 * Message text:
	 * An error occurred while starting the JMS connector.
	 */
	public static final Message CONNECTOR_START_EXCEPTION = MESSAGE_SET.getMessage("connectorStartException");
	/**
	 * Holds the definition of the message with ID connectorStopped.
	 * Message text:
	 * JMS connector stopped.
	 */
	public static final Message CONNECTOR_STOPPED = MESSAGE_SET.getMessage("connectorStopped");
	/**
	 * Holds the definition of the message with ID connectorReset.
	 * Message text:
	 * Resetting JMS connector
	 */
	public static final Message CONNECTOR_RESET = MESSAGE_SET.getMessage("connectorReset");
	/**
	 * Holds the definition of the message with ID problemJmsConnection.
	 * Message text:
	 * An error has occurred while opening a connection to message queue. {0}
	 */
	public static final Message PROBLEM_JMS_CONNECTION = MESSAGE_SET.getMessage("problemJmsConnection");
	/**
	 * Holds the definition of the message with ID problemResolvedJmsConnection.
	 * Message text:
	 * Message queue connection recovered.
	 */
	public static final Message PROBLEM_RESOLVED_JMS_CONNECTION = MESSAGE_SET.getMessage("problemResolvedJmsConnection");
	/**
	 * Holds the definition of the message with ID transactionAbort.
	 * Message text:
	 * Aborted the transaction.
	 */
	public static final Message TRANSACTION_ABORT = MESSAGE_SET.getMessage("transactionAbort");
	/**
	 * Holds the definition of the message with ID transactionCommit.
	 * Message text:
	 * Committed the transaction.
	 */
	public static final Message TRANSACTION_COMMIT = MESSAGE_SET.getMessage("transactionCommit");
	/**
	 * Holds the definition of the message with ID transactionError.
	 * Message text:
	 * An error occurred while processing the SOAP request: {0}
	 */
	public static final Message TRANSACTION_ERROR = MESSAGE_SET.getMessage("transactionError");
	/**
	 * Holds the definition of the message with ID destinationInitialize.
	 * Message text:
	 * Initializing destination {0}
	 */
	public static final Message DESTINATION_INITIALIZE = MESSAGE_SET.getMessage("destinationInitialize");
	/**
	 * Holds the definition of the message with ID destinationStarting.
	 * Message text:
	 * Starting destination {0}
	 */
	public static final Message DESTINATION_STARTING = MESSAGE_SET.getMessage("destinationStarting");
	/**
	 * Holds the definition of the message with ID destinationInitializationJndiError.
	 * Message text:
	 * Destination {0} not found in JNDI
	 */
	public static final Message DESTINATION_INITIALIZATION_JNDI_ERROR = MESSAGE_SET.getMessage("destinationInitializationJndiError");
	/**
	 * Holds the definition of the message with ID destinationInitializationError.
	 * Message text:
	 * Error while initializing {0}
	 */
	public static final Message DESTINATION_INITIALIZATION_ERROR = MESSAGE_SET.getMessage("destinationInitializationError");
	/**
	 * Holds the definition of the message with ID destinationSendMessageError.
	 * Message text:
	 * JMS Exception at sending to destination {0}
	 */
	public static final Message DESTINATION_SEND_MESSAGE_ERROR = MESSAGE_SET.getMessage("destinationSendMessageError");
	/**
	 * Holds the definition of the message with ID destinationBTCParseError.
	 * Message text:
	 * Binary transformation parse error at sending to destination {0}
	 */
	public static final Message DESTINATION_BTCPARSE_ERROR = MESSAGE_SET.getMessage("destinationBTCParseError");
	/**
	 * Holds the definition of the message with ID destinationGetMessageError.
	 * Message text:
	 * Exception while receiving from destination {0}
	 */
	public static final Message DESTINATION_GET_MESSAGE_ERROR = MESSAGE_SET.getMessage("destinationGetMessageError");
	/**
	 * Holds the definition of the message with ID destinationGetMessageErrorQueueError.
	 * Message text:
	 * JMS Exception while sending message to error queue {0}
	 */
	public static final Message DESTINATION_GET_MESSAGE_ERROR_QUEUE_ERROR = MESSAGE_SET.getMessage("destinationGetMessageErrorQueueError");
	/**
	 * Holds the definition of the message with ID destinationSendErrorMessage.
	 * Message text:
	 * Sending message to error queue {0}
	 */
	public static final Message DESTINATION_SEND_ERROR_MESSAGE = MESSAGE_SET.getMessage("destinationSendErrorMessage");
	/**
	 * Holds the definition of the message with ID jmxDestianationSubcomponenetName.
	 * Message text:
	 * A JMS destination
	 */
	public static final Message JMX_DESTIANATION_SUBCOMPONENET_NAME = MESSAGE_SET.getMessage("jmxDestianationSubcomponenetName");
	/**
	 * Holds the definition of the message with ID jmxHandledIncomingMessageCount.
	 * Message text:
	 * The amount of messages red from the destination and the time it took to handle them
	 */
	public static final Message JMX_HANDLED_INCOMING_MESSAGE_COUNT = MESSAGE_SET.getMessage("jmxHandledIncomingMessageCount");
	/**
	 * Holds the definition of the message with ID jmxHandledOutgoingMessageCount.
	 * Message text:
	 * The amount of messages send from the destination and the time it took to handle them
	 */
	public static final Message JMX_HANDLED_OUTGOING_MESSAGE_COUNT = MESSAGE_SET.getMessage("jmxHandledOutgoingMessageCount");
	/**
	 * Holds the definition of the message with ID jmxMessageHandlingErrorCounter.
	 * Message text:
	 * The amount of messages that resulted in an error
	 */
	public static final Message JMX_MESSAGE_HANDLING_ERROR_COUNTER = MESSAGE_SET.getMessage("jmxMessageHandlingErrorCounter");
	/**
	 * Holds the definition of the message with ID DESTINATIONMANAGER_INITIALIZING.
	 * Message text:
	 * Initializing destination manager {0}.
	 */
	public static final Message DESTINATIONMANAGER_INITIALIZING = MESSAGE_SET.getMessage("DESTINATIONMANAGER_INITIALIZING");
	/**
	 * Holds the definition of the message with ID JMX_DESTINATION_MANAGER_SUBCOMPONENT_NAME.
	 * Message text:
	 * A destination manager
	 */
	public static final Message JMX_DESTINATION_MANAGER_SUBCOMPONENT_NAME = MESSAGE_SET.getMessage("JMX_DESTINATION_MANAGER_SUBCOMPONENT_NAME");
	/**
	 * Holds the definition of the message with ID DESTINATIONMANAGER_CONNECTION_ERROR.
	 * Message text:
	 * Could not connect to destination manager {0}. Check if the middleware system is running and reachable.
	 */
	public static final Message DESTINATIONMANAGER_CONNECTION_ERROR = MESSAGE_SET.getMessage("DESTINATIONMANAGER_CONNECTION_ERROR");
	/**
	 * Holds the definition of the message with ID DESTINATIONMANAGER_JNDI_LOOKUP_FAILURE.
	 * Message text:
	 * JNDI not found or destination manager {0} not found in JNDI.
	 */
	public static final Message DESTINATIONMANAGER_JNDI_LOOKUP_FAILURE = MESSAGE_SET.getMessage("DESTINATIONMANAGER_JNDI_LOOKUP_FAILURE");
	/**
	 * Holds the definition of the message with ID DESTINATIONMANAGER_UNABLE_TO_INITIALIZE.
	 * Message text:
	 * Error while initializing destination manager {0}.
	 */
	public static final Message DESTINATIONMANAGER_UNABLE_TO_INITIALIZE = MESSAGE_SET.getMessage("DESTINATIONMANAGER_UNABLE_TO_INITIALIZE");
	/**
	 * Holds the definition of the message with ID DESTINATIONMANAGER_STARTING.
	 * Message text:
	 * Starting destination manager {0}.
	 */
	public static final Message DESTINATIONMANAGER_STARTING = MESSAGE_SET.getMessage("DESTINATIONMANAGER_STARTING");
	/**
	 * Holds the definition of the message with ID DESTINATIONMANAGER_RESTARTING.
	 * Message text:
	 * Got connection to JMS provider - restarting destination manager {0}.
	 */
	public static final Message DESTINATIONMANAGER_RESTARTING = MESSAGE_SET.getMessage("DESTINATIONMANAGER_RESTARTING");
	/**
	 * Holds the definition of the message with ID DESTINATIONMANAGER_TRYING_TO_RESTART.
	 * Message text:
	 * Trying to restart Destination Manager {0}.
	 */
	public static final Message DESTINATIONMANAGER_TRYING_TO_RESTART = MESSAGE_SET.getMessage("DESTINATIONMANAGER_TRYING_TO_RESTART");
	/**
	 * Holds the definition of the message with ID DESTINATIONMANAGER_UNABLE_TO_RESTART.
	 * Message text:
	 * Not able to restart Destination Manager {0}. Issue: {1}
	 */
	public static final Message DESTINATIONMANAGER_UNABLE_TO_RESTART = MESSAGE_SET.getMessage("DESTINATIONMANAGER_UNABLE_TO_RESTART");
	/**
	 * Holds the definition of the message with ID TRIGGER_INITIALIZING.
	 * Message text:
	 * Initializing trigger {0}.
	 */
	public static final Message TRIGGER_INITIALIZING = MESSAGE_SET.getMessage("TRIGGER_INITIALIZING");
	/**
	 * Holds the definition of the message with ID JMX_TRIGGER_SUBCOMPONENT_NAME.
	 * Message text:
	 * A trigger defined for this destination.
	 */
	public static final Message JMX_TRIGGER_SUBCOMPONENT_NAME = MESSAGE_SET.getMessage("JMX_TRIGGER_SUBCOMPONENT_NAME");
	/**
	 * Holds the definition of the message with ID JMX_TRIGGER_MESSAGE_HANDLING_COUNTER_NAME.
	 * Message text:
	 * The amount of messages read from the destination and the time it took to handle them.
	 */
	public static final Message JMX_TRIGGER_MESSAGE_HANDLING_COUNTER_NAME = MESSAGE_SET.getMessage("JMX_TRIGGER_MESSAGE_HANDLING_COUNTER_NAME");
	/**
	 * Holds the definition of the message with ID JMX_TRIGGER_MESSAGE_HANDLING_ERROR_COUNTER_NAME.
	 * Message text:
	 * The amount of messages that resulted in an error.
	 */
	public static final Message JMX_TRIGGER_MESSAGE_HANDLING_ERROR_COUNTER_NAME = MESSAGE_SET.getMessage("JMX_TRIGGER_MESSAGE_HANDLING_ERROR_COUNTER_NAME");
	/**
	 * Holds the definition of the message with ID TRIGGER_EXECUTION_ERROR.
	 * Message text:
	 * Exception at execution of trigger after receiving message from destination {0}. Received response: {1}."
	 */
	public static final Message TRIGGER_EXECUTION_ERROR = MESSAGE_SET.getMessage("TRIGGER_EXECUTION_ERROR");
	/**
	 * Holds the definition of the message with ID TRIGGER_RECEIVE_ERROR.
	 * Message text:
	 * JMS Exception at receiving from destination {0}. MessageID = {1}
	 */
	public static final Message TRIGGER_RECEIVE_ERROR = MESSAGE_SET.getMessage("TRIGGER_RECEIVE_ERROR");
	/**
	 * Holds the definition of the message with ID TRIGGER_ERROR_SENDING_TO_ERROR_DESTINATION.
	 * Message text:
	 * JMS Exception at sending message to error destination  {0}. MessageID = {1}
	 */
	public static final Message TRIGGER_ERROR_SENDING_TO_ERROR_DESTINATION = MESSAGE_SET.getMessage("TRIGGER_ERROR_SENDING_TO_ERROR_DESTINATION");
	/**
	 * Holds the definition of the message with ID TRIGGER_MESSAGE_SENT_TO_ERROR_DESTINATION.
	 * Message text:
	 * Message {1} has been sent to to error destination {0} with ID {2}
	 */
	public static final Message TRIGGER_MESSAGE_SENT_TO_ERROR_DESTINATION = MESSAGE_SET.getMessage("TRIGGER_MESSAGE_SENT_TO_ERROR_DESTINATION");
	/**
	 * Holds the definition of the message with ID TRIGGER_ROLLBACK_ERROR.
	 * Message text:
	 * JMS Exception at rolling back message from destination {0}. MessageID = {1}
	 */
	public static final Message TRIGGER_ROLLBACK_ERROR = MESSAGE_SET.getMessage("TRIGGER_ROLLBACK_ERROR");
	/**
	 * Holds the definition of the message with ID DESTINATION_MULTIPLE_DYNAMIC_DESTINATIONS.
	 * Message text:
	 * Destination manager {0} already has a dynamic destination set. 
	 * Triggers will use the already set destination.
	 */
	public static final Message DESTINATION_MULTIPLE_DYNAMIC_DESTINATIONS = MESSAGE_SET.getMessage("DESTINATION_MULTIPLE_DYNAMIC_DESTINATIONS");
	/**
	 * Holds the definition of the message with ID DESTINATION_ERROR_DESTINATION_ALREADY_SET.
	 * Message text:
	 * Destination manager {0} already has a default error destination. Setting for destination {0} is ignored.
	 */
	public static final Message DESTINATION_ERROR_DESTINATION_ALREADY_SET = MESSAGE_SET.getMessage("DESTINATION_ERROR_DESTINATION_ALREADY_SET");
	/**
	 * Holds the definition of the message with ID doNotProcessRedeliveredMessage.
	 * Message text:
	 * Message with ID {0} is redelivered from destination {1}. Hence ignoring the message.
	 */
	public static final Message DO_NOT_PROCESS_REDELIVERED_MESSAGE = MESSAGE_SET.getMessage("doNotProcessRedeliveredMessage");
	
	
	public static final String getFormatted(Message message, Object[] inserts){
		MessageFormat format = new MessageFormat(LogMessages.DO_NOT_PROCESS_REDELIVERED_MESSAGE.getMessage(Locale.getDefault()));
		String formattedMessage = format.format(inserts);
		return formattedMessage;
	}
	

}